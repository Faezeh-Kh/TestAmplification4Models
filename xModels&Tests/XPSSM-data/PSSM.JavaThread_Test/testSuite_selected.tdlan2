Package testSuite {
	//test cases
//	Test Description test1 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//	}
//	Test Description test2 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test3 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//	}
//	Test Description test4 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = Thread_yield_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	
//	Test Description test5 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSuspended_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test6 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
	}
	Test Description test7 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
	}
//	Test Description test8 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//	}
//	Test Description test9 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//	}
//	Test Description test10 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//	}
//	Test Description test11 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//	}
//	Test Description test12 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = sleepTimeElapsed_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test13 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = sleepTimeElapsed_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
	}
//	Test Description test14 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = sleepTimeElapsed_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test15 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = sleepTimeElapsed_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test16 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = sleepTimeElapsed_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test17 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
	Test Description test18 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
	}
//	Test Description test19 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test20 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test21 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test22 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
	Test Description test23 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
	}
	Test Description test24 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
	}
//	Test Description test25 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test26 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test27 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test28 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test29 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
	Test Description test30 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
	}
//	Test Description test31 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test32 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//	}
//	Test Description test33 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//	}
//	Test Description test34 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//	}
//	Test Description test35 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test36 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test37 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
	Test Description test38 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
	}
//	Test Description test39 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test40 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test41 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test42 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test43 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test44 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToEnterSynchroBlock_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test45 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToReenterSynchroBlock_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//	}
//	Test Description test46 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToEnterSynchroBlock_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test47 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToReenterSynchroBlock_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
	}
//	Test Description test48 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToEnterSynchroBlock_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test49 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = waitForLockToReenterSynchroBlock_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test50 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test51 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test52 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
	}
//	Test Description test53 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test54 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test55 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
	}
//	Test Description test56 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test57 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test58 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test59 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
	Test Description test60 uses configuration JavaThreadLifeCycleConfiguration{
		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
		) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
	}
//	Test Description test61 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test62 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test63 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test64 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test65 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = Thread_sleep___occurrence (inParameterValues = sleepTimeValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test66 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = o_wait___occurrence (inParameterValues = waitTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test67 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends callOperation_received (state_machine = JaveThreadStates, 
//			call_occurrence = t_join___occurrence (inParameterValues = joinTimeoutValue (value = "10"))
//		) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test68 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkNanos___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test69 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, 
//			signal_occurrence = LockSupport_parkUntil___occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaitingByTime) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test70 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test71 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test72 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test73 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test74 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test75 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = monitorLockAcquired_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//	}
//	Test Description test76 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test77 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test78 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notifyAll_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test79 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_wait_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test80 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_join_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
//	Test Description test81 uses configuration JavaThreadLifeCycleConfiguration{
//		tester.reactiveGate sends _run (state_machine = JaveThreadStates) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = newThreadCreated) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = t_start_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunnable) to tester.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsReady) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = threadSelected2Run_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsRunning) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = finishRunnable_occurrence) to statemachine.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = LockSupport_park_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsWaiting) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = o_notify_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsBlocked) to tester.reactiveGate;
//		tester.reactiveGate sends signal_received (state_machine = JaveThreadStates, signal_occurrence = ThreadTerminated_occurrence) to statemachine.reactiveGate;
//		statemachine.reactiveGate sends behavior_executed (behavior = ThreadIsTerminated) to tester.reactiveGate;
//	}
	//types
	Type CustomSystem ( statemachine of type StateMachine , signals of type Signal , operations of type Operation ) ;
	Type Signal extends NamedElement ( attributes of type Attribute ) ;
	Type Operation extends NamedElement ( inParameters of type Attribute , outParameters of type Attribute , return of type Attribute ) ;
	Type EventType ( ) with {
		abstract ;
	} ;
	Type SignalEventType extends EventType ( signal of type Signal ) ;
	Type CallEventType extends EventType ( operation of type Operation ) ;
	Type Attribute extends NamedElement ( ) with {
		abstract ;
	} ;
	Type BooleanAttribute extends Attribute ( ) ;
	Type IntegerAttribute extends Attribute ( ) ;
	Type StringAttribute extends Attribute ( ) ;
	Type Constraint ( ) with {
		abstract ;
	} ;
	Type BooleanConstraint extends Constraint ( attribute of type BooleanAttribute , value of type EBooleanObject ) ;
	Type IntegerConstraint extends Constraint ( attribute of type IntegerAttribute , value of type EIntegerObject ) ;
	Type StringConstraint extends Constraint ( attribute of type StringAttribute , value of type EString ) ;
	Type NamedElement ( _name of type EString ) with {
		abstract ;
	} ;
	Type StateMachine extends NamedElement ( regions of type Region ) ;
	Type Region extends NamedElement ( vertice of type Vertex , transitions of type Transition , stateMachine of type StateMachine , state of type State , currentVertex of type Vertex with { dynamic ;
	} ) ;
	Type Vertex extends NamedElement ( container of type Region , outgoingTransitions of type Transition , incomingTransitions of type Transition ) with {
		abstract ;
	} ;
	Type Pseudostate extends Vertex ( kind of type PseudostateKind , state of type State ) ;
	Type State extends Vertex ( regions of type Region , entry of type Behavior , doActivity of type Behavior , exit of type Behavior , deferrableTriggers of type Trigger , connectionPoint of type Pseudostate ) ;
	Type FinalState extends State ( ) ;
	Type Transition extends NamedElement ( source of type Vertex , target of type Vertex , _triggers of type Trigger , container of type Region , kind of type TransitionKind , effect of type Behavior , constraint of type Constraint ) ;
	Type Trigger extends NamedElement ( eventType of type EventType ) ;
	Type Behavior extends NamedElement ( emittedSignals of type SignalEventOccurrence ) ;
	Type OperationBehavior extends Behavior ( attributeValues of type AttributeValue ) ;
	Type AttributeValue ( ) ;
	Type BooleanAttributeValue extends AttributeValue ( attribute of type BooleanAttribute , value of type EBooleanObject ) ;
	Type IntegerAttributeValue extends AttributeValue ( attribute of type IntegerAttribute , value of type EIntegerObject ) ;
	Type StringAttributeValue extends AttributeValue ( attribute of type StringAttribute , value of type EString ) ;
	Type EventOccurrence ( ) with {
		abstract ;
	} ;
	Type CompletionEventOccurrence ( state of type State ) ;
	Type SignalEventOccurrence extends EventOccurrence ( signal of type Signal , attributeValues of type AttributeValue with { dynamic ;
	} ) ;
	Type CallEventOccurrence extends EventOccurrence ( operation of type Operation , inParameterValues of type AttributeValue with { dynamic ;
	} , outParameterValues of type AttributeValue with { dynamic ; } , returnValue of type AttributeValue with { dynamic ; } ) ;
	Type PseudostateKind ;
	Type TransitionKind ;
	Type BooleanBinaryOperator ;
	Type BooleanUnaryOperator ;
	Type IntegerComparisonOperator ;
	Type StringComparisonOperator ;
	BooleanBinaryOperator AND ;
	BooleanBinaryOperator OR ;
	BooleanUnaryOperator NOT ;
	PseudostateKind initial ;
	PseudostateKind join ;
	PseudostateKind fork ;
	PseudostateKind _terminate ;
	PseudostateKind entrypoint ;
	PseudostateKind exitpoint ;
	StringComparisonOperator _EQUALS ;
	TransitionKind internal ;
	TransitionKind local ;
	TransitionKind external ;
	IntegerComparisonOperator SMALLER ;
	IntegerComparisonOperator SMALLER_EQUALS ;
	IntegerComparisonOperator EQUALS ;
	IntegerComparisonOperator GREATER_EQUALS ;
	IntegerComparisonOperator GREATER ;
	IntegerComparisonOperator NOT_EQUALS ;
	Annotation dynamic ;
	Annotation abstract ;
	Type EByteArray ;
	Type EFloat ;
	Type EBoolean ;
	Type EFeatureMapEntry ;
	Type EResource ;
	Type EBooleanObject ;
	Type EFeatureMap ;
	Type EJavaClass ;
	Type EInvocationTargetException ;
	Type EChar ;
	Type ELongObject ;
	Type EInt ;
	Type EShort ;
	Type EJavaObject ;
	Type EBigDecimal ;
	Type EByte ;
	Type EString ;
	Type ETreeIterator ;
	Type EFloatObject ;
	Type EDate ;
	Type EDoubleObject ;
	Type EIntegerObject ;
	Type EBigInteger ;
	Type EByteObject ;
	Type EShortObject ;
	Type EEList ;
	Type ELong ;
	Type EDiagnosticChain ;
	Type EResourceSet ;
	Type EEnumerator ;
	Type ECharacterObject ;
	Type EDouble ;
	Type EMap ;
	
	//common
	Type OCL ( query of type EString ) ;
	OCL oclQuery ( query = ? ) ;
	Type Verdict ;
	Verdict PASS ;
	Verdict FAIL ;
	Verdict INCONCLUSINVE ;
	Type modelExecutionCommand ;
	modelExecutionCommand runModel ;
	modelExecutionCommand runModelAsynchronous ;
	modelExecutionCommand stopModelExecution ;
	modelExecutionCommand resetModel ;
	modelExecutionCommand getModelState ;
	
	//events
	Annotation AcceptedEvent ;
	Annotation ExposedEvent ;
	Type _run ( state_machine of type StateMachine ) with {
		AcceptedEvent ;
	} ;
	_run _run ( state_machine = ? ) ;
	Type signal_received ( state_machine of type StateMachine , signal_occurrence of type SignalEventOccurrence ) with {
		AcceptedEvent ;
	} ;
	signal_received signal_received ( state_machine = ? , signal_occurrence = ? ) ;
	Type callOperation_received ( state_machine of type StateMachine , call_occurrence of type CallEventOccurrence ) with {
		AcceptedEvent ;
	} ;
	callOperation_received callOperation_received ( state_machine = ? , call_occurrence = ? ) ;
	Type behavior_executed ( behavior of type Behavior ) with {
		ExposedEvent ;
	} ;
	behavior_executed behavior_executed ( behavior = ? ) ;
	
	//configuration
	Gate Type genericGateType accepts modelExecutionCommand ;
	Gate Type reactiveGateType accepts _run , signal_received , callOperation_received , behavior_executed ;
	Gate Type oclGateType accepts OCL ;
	
	Component Type TestSystem having {
		//gate genericGate of type genericGateType ;
		gate reactiveGate of type reactiveGateType ; 
		gate oclGate of type oclGateType ;
	}
	Component Type MUT having {
		//gate genericGate of type genericGateType ;
		gate reactiveGate of type reactiveGateType ; 
		gate oclGate of type oclGateType ;
	}
	Annotation MUTPath ;
	Annotation DSLName ;
	
	Test Configuration JavaThreadLifeCycleConfiguration {
		create Tester tester of type TestSystem ;
		create SUT statemachine of type MUT with { 
			MUTPath : '/PSSM.JavaThread_Mutants3/JavaThreadLifeCycle.model' ; 
			DSLName : 'org.imt.pssm.reactive.ReactivePSSM' ;
		} ;
		//connect tester.genericGate to statemachine.genericGate;
		//connect tester.oclGate to statemachine.oclGate ;
		connect tester.reactiveGate to statemachine.reactiveGate ;
	}
	
	//test data
	StateMachine JaveThreadStates ( _name = "JaveThreadStates" ) ;
	Behavior newThreadCreated ( _name = "newThreadCreated" ) ;
	Behavior ThreadIsReady ( _name = "ThreadIsReady" ) ;
	Behavior ThreadIsRunning ( _name = "ThreadIsRunning" ) ;
	Behavior ThreadIsRunnable ( _name = "ThreadIsRunnable" ) ;
	Behavior ThreadIsWaitingByTime ( _name = "ThreadIsWaitingByTime" ) ;
	Behavior ThreadIsWaiting ( _name = "ThreadIsWaiting" ) ;
	Behavior ThreadIsBlocked ( _name = "ThreadIsBlocked" ) ;
	Behavior ThreadIsTerminated ( _name = "ThreadIsTerminated" ) ;
	Signal t_start ( _name = "t.start" ) ;
	SignalEventOccurrence t_start_occurrence ( signal = t_start ) ;
	Signal threadSelected2Run ( _name = "threadSelected2Run" ) ;
	SignalEventOccurrence finishRunnable_occurrence ( signal = finishRunnable ) ;
	Signal finishRunnable ( _name = "finishRunnable" ) ;
	SignalEventOccurrence threadSelected2Run_occurrence ( signal = threadSelected2Run ) ;
	Signal Thread_yield ( _name = "Thread.yield" ) ;
	SignalEventOccurrence Thread_yield_occurrence ( signal = Thread_yield ) ;
	Signal threadSuspended ( _name = "threadSuspended" ) ;
	SignalEventOccurrence threadSuspended_occurrence ( signal = threadSuspended ) ;
	Signal LockSupport_parkNanos__ ( _name = "LockSupport.parkNanos()" ) ;
	SignalEventOccurrence LockSupport_parkNanos___occurrence ( signal = LockSupport_parkNanos__ ) ;
	Signal LockSupport_parkUntil__ ( _name = "LockSupport.parkUntil()" ) ;
	SignalEventOccurrence LockSupport_parkUntil___occurrence ( signal = LockSupport_parkUntil__ ) ;
	Signal o_wait ( _name = "o.wait" ) ;
	SignalEventOccurrence o_wait_occurrence ( signal = o_wait ) ;
	Signal t_join ( _name = "t.join" ) ;
	SignalEventOccurrence t_join_occurrence ( signal = t_join ) ;
	Signal LockSupport_park ( _name = "LockSupport.park" ) ;
	SignalEventOccurrence LockSupport_park_occurrence ( signal = LockSupport_park ) ;
	Signal waitForLockToEnterSynchroBlock ( _name = "waitForLockToEnterSynchroBlock" ) ;
	SignalEventOccurrence waitForLockToEnterSynchroBlock_occurrence ( signal = waitForLockToEnterSynchroBlock ) ;
	Signal waitForLockToReenterSynchroBlock ( _name = "waitForLockToReenterSynchroBlock" ) ;
	SignalEventOccurrence waitForLockToReenterSynchroBlock_occurrence ( signal = waitForLockToReenterSynchroBlock ) ;
	Signal sleepTimeElapsed ( _name = "sleepTimeElapsed" ) ;
	SignalEventOccurrence sleepTimeElapsed_occurrence ( signal = sleepTimeElapsed ) ;
	Signal ThreadTerminated ( _name = "ThreadTerminated" ) ;
	SignalEventOccurrence ThreadTerminated_occurrence ( signal = ThreadTerminated ) ;
	Signal o_notifyAll ( _name = "o.notifyAll" ) ;
	SignalEventOccurrence o_notifyAll_occurrence ( signal = o_notifyAll ) ;
	Signal o_notify ( _name = "o.notify" ) ;
	SignalEventOccurrence o_notify_occurrence ( signal = o_notify ) ;
	Signal monitorLockAcquired ( _name = "monitorLockAcquired" ) ;
	SignalEventOccurrence monitorLockAcquired_occurrence ( signal = monitorLockAcquired ) ;
	IntegerAttribute sleepTime (_name = "sleeptime");
	IntegerAttributeValue sleepTimeValue ( attribute = sleepTime ) ;
	Operation Thread_sleep__ ( _name = "Thread.sleep()" , inParameters = sleepTime);
	CallEventOccurrence Thread_sleep___occurrence ( operation = Thread_sleep__ ) ;
	IntegerAttribute waitTimeout (_name = "waitTimeout");
	IntegerAttributeValue waitTimeoutValue ( attribute = waitTimeout ) ;
	Operation o_wait__ ( _name = "o.wait()" , inParameters = waitTimeout) ;
	CallEventOccurrence o_wait___occurrence ( operation = o_wait__ ) ;
	IntegerAttribute joinTimeout (_name = "joinTimeout");
	IntegerAttributeValue joinTimeoutValue ( attribute = joinTimeout ) ;
	Operation t_join__ ( _name = "t.join()" , inParameters = joinTimeout) ;
	CallEventOccurrence t_join___occurrence ( operation = t_join__ ) ;
}