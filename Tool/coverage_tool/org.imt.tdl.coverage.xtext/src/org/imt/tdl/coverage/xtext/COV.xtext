// automatically generated by Xtext
grammar org.imt.tdl.coverage.xtext.COV with org.eclipse.xtext.common.Terminals

import "https://org.imt.tdl.coverage/DSLSpecificCoverage" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DomainSpecificCoverage returns DomainSpecificCoverage:
	'ruleset'
	name=EString
	'{'
		'import' 'metamodel' metamodel=[ecore::EPackage|EString]
		('import' 'ruleset' imports+=Import ("," imports+=Import)*)?
		contexts+=Context ( "," contexts+=Context)*
	'}';
	
Import returns Import:
	{Import}
	('with' importedNamespace=ImportedFQN ('from' importURI=STRING)?) |
	('from' importURI=STRING)|
	(importedRuleset=[DomainSpecificCoverage|EString])
	;

QualifiedName: ID ('::' ID)*;
ImportedFQN: QualifiedName ('::''*')?;
	 
EString returns ecore::EString:
	STRING | ID;

Context returns Context:
	'context' metaclass=[ecore::EClass|EString]
	'{'
		(rules+=Rule ( "," rules+=Rule)*)?
	'}';

Rule returns Rule:
	Ignore |
	LimitedIgnore |
	CoverageOfReferenced |
	CoverageByContent |
	BranchSpecification;

Ignore returns Ignore:
	{Ignore} 
	('when' condition=Condition)?
	'ignore' '(' ('subtypes' ignoreSubtypes=EBoolean)? ')'
	('description' description=EString)?;
	
LimitedIgnore returns LimitedIgnore:
	{LimitedIgnore}
	('when' condition=Condition)?
	'ignoreif' type=LimitationType
		containerMetaclass+=[ecore::EClass|EString] ( "," containerMetaclass+=[ecore::EClass|EString])*
	('description' description=EString)?;
	
CoverageOfReferenced returns CoverageOfReferenced:
	{CoverageOfReferenced}
	('when' condition=Condition)?
	'covers' reference+=[ecore::EReference|EString] ("," reference+=[ecore::EReference|EString])*
	('description' description=EString)?;
	
CoverageByContent returns CoverageByContent:
	{CoverageByContent}
	('when' condition=Condition)?
	'covered' 'when' multiplicity=CoveredContents (containmentReference=[ecore::EReference|EString])? 'iscovered'
	('description' description=EString)?;
		

BranchSpecification returns BranchSpecification:
	{BranchSpecification}
	('when' condition=Condition)?
	'{' 
		branches += Branch (',' branches += Branch)* 
		('description' description=STRING)?
	'}';
	
Branch returns Branch:
	ImplicitBranch | ExplicitBranch;

ExplicitBranch returns ExplicitBranch: 
	'branch' OCLQuery=STRING;

ImplicitBranch returns ImplicitBranch: 
	{ImplicitBranch} 
	'branch' 'else'   
	;

Condition returns Condition:
	OCLConstraint=STRING;
	
enum CoveredContents returns CoveredContents:
	ALL = 'ALL' | ONE = 'ONE' | ANY = 'anyContent';

enum LimitationType returns LimitationType:
	containedBy = 'containedBy' | notContainedBy = 'notContainedBy';
	
	
EBoolean returns ecore::EBoolean:
	'true' | 'false';
